---
title: java 객체지향 한장정리 (2)
date: '2018-09-07 00:00:00'
categories: java
tags: [java, 객체지향]
---

`자바의 정석 7장 정리`

## 1. 상속

### 1) 상속이란?

* 기존의 클래스를 재사용해서 새로운 클래스를 작성
* 조상과 자손으로 관계맺음
* 자손은 조상의 모든 멤버 상속받음
* 사용법

```java
class 자손클래스 extends 조상클래스{}
```

### 2) 상속관계

* 공통부분 조상에서, 개별부분 자손에서 관리

### 3) 포함관계

* 한 클래스의 멤버 변수로 다른 클래스 선언

### 4) 단일상속

* Java는 단일상속만을 허용

### 5) Object 클래스

* 조상없는 클래스는 object클래스 상속

## 2. 오버라이딩

### 1) 오버라이딩이란?

* 조상메서드를 자손에 맞게 변경(덮어쓰기)

### 2) 조건

1. 선언부가 같아야 함
2. 접근제어자 좁은 범위로 변경 x (public->private x)
3. 조상보다 많은 수의 예외 x
4. 내부만 변경

### 3) 오버로딩 vs 오버라이딩

* 오버로딩
    - 새로운 메서드 정의(new)
    - 상속과 관련 x
* 오버라이딩
    - 상속받은 메서드의 내용변경(change)

### 4) super 참조변수

1. this vs super
    - this: 인스턴스 자신의 참조변수
    - super: 조상의 참조변수

2. super() 조상의 생성자
    - 자손 인스턴스 생성시, 자손+조상 멤버 합친 하나의 인스턴스 생성
    - 자손 생성자의 첫 문장에서 호출(조상 멤버로 초기화 되어야 함)

## 3. Package와 Import

### 1) 패키지

* 서로 관련된 클래스와 인터페이스의 묶음
* 클래스는 파일, 패키지는 폴더
* \.으로 구분

### 2) x
### 3) 클래스패스 설정 (x)
### 4) Import

* 사용할 클래스가 속한 패키지 지정
* 컴파일시 처리

## 4. 제어자

### 1) 제어자란?

* 클래스, 변수, 메서드 선언부에 사용되어 부가적인 의미 부여
* public, protected, (default), private (넓->좁)

### 2)~6) (x)
### 7) 접근제어자 (캡슐화) 사용 이유

1. 외부로부터 데이터 보호위해
2. 내부적으로만 사용되는 부분 감추기 위해

## 5. 다형성

### 1) 다형성이란?

* 조상타입의 참조변수로 자손타입의 인스턴스를 다룰 수 있는 것

### 2) 참조변수의 형변환

* 상속관계 타입간만 형변환 가능
* 값은 그대로. 사용할 수 있는 멤버개수만 달라짐

### 3) instanceof 연산자

* 형변환 가능 여부 확인
* 실제 타입 체크

### 4) (x)
### 5) 매개변수의 다형성 (다형성의 장점 1)

* 참조형 매개변수는 메서드 호출시 자신과 같은 타입 or 자손 타입의 인스턴스를 넘겨줄 수 있다
* 여러개 조상들이 공통으로 사용하는 함수의 매개변수에 조상의 매개변수를 쓰면? -> 자손까지 그 함수 사용가능

### 6) 여러 종류의 객체를 배열로 다루기 (다형성의 장점 2)

## 6. 추상클래스

### 1) 추상클래스란?

* 미완성 설계도
* 추상 메서드를 포함하고 있는 클래스
* 왜? -> 클래스 선언부의 abstract를 보고 이 클래스에는 추상메서드가 있으니 상속을 통해서 구현해주어야 한다는 것을 쉽게 알 수 있기 때문
* 생성자, 멤버변수, 메서드 모두 가질 수 있다.

`abstract class 클래스이름 { ... }`

### 2) 추상메서드란?

* 선언부만 작성하고 구현부(body)는 작성하지 않은 채로 남겨 둔 것
* 왜? -> 메서드의 내용을 상속받는 클래스에 따라 다르게 만들고 싶어서
* 구현부가 없어서 중괄호{}를 넣지 않는다

`abstract 리턴타입 메서드이름();`

> 자손클래스에서 오버라이딩해도 되는데 굳이 왜? -> 자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해(빈 메소드인지 알기 어렵다)

## 7. 인터페이스

### 1) 인터페이스란?

* 껍데기 설계도
* 추상메서드의 집합(예외: default, static method / 상수는 신경쓰지 말자)

### 2) 인터페이스의 작성

```java
interface 인터페이스이름 { // class 대신 interface
    public static final 타입 상수이름 = 값; // 상수
    public abstract 메서드이름(매개변수); // 추상메서드
}
```

* public static final / public abstract 생략가능

### 3) 인터페이스의 상속

* 인터페이스로부터만 상속받을 수 있음
* 다중상속 가능

### 4) 인터페이스의 구현(implements)

* extends대신 implements
* 상속과 구현 동시에 사용 가능

```java
class 클래스이름 implements 인터페이스이름 { // 완성할때는 일반 class
    // 추상메서드 구현
}
class Fighter extends Unit implements Fightable {
    // ...
}
```

### 5) 인터페이스를 이용한 다중상속(참고만)

### 6) *인터페이스를 이용한 다형성(중요)*

* 다형성 : 조상타입의 참조변수로 자손클래스의 인스턴스를 참조가능
* 인터페이스 다형성 : 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조가능

```java
Fightable f = (Fightable) new Fighter();
//또는
Fightable f = new Fighter();

```

* Fightable타입의 참조변수로는 인터페이스 Fightable에 정의된 멤버들만 호출가능
* 비유) 옛날 리모컨으로 현재 TV조작가능 but 새로운 기능 사용불가 (리모컨에 버튼이 없음)

### 7) 인터페이스의 장점

1. 개발시간 단축
    * A팀과 B팀이 동시에 개발가능
    * 인터페이스 작성
    * A팀은 메서드의 내용 작성
    * B팀은 메서드를 호출하여 프로그래밍

2. 표준화 가능
    
    * Oracle, MySQL등 다양한 데이터베이스 대응 힘듬
    * Java - JDBC(인터페이스)만을 이용해 DB개발
    * 각 DB회사들이 JDBC인터페이스로 연결되는 부분 개발

3. 클래스에 새로운 공통점 만들어서 연결 가능

    * SCV(지상), 탱크(지상), 드랍쉽(공중) 유닛간 묶기 어려움
    * 고칠수 있다는 공통특징으로 주어 묶고 싶을 때 사용

    ```java
    class SCV extends GroundUnit implements Repairable {}
    class Tank extends GroundUnit implements Repairable {}
    class Dropship extends AirUnit implements Repairable {}
    ```

4. 독립적인 프로그래밍 가능
* 선언과 구현을 분리시킬 수 있다

### 8) 인터페이스의 이해

* 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.
* 메서드를 사용하는 쪽에서는 사용하려는 메서드의 선언부만 알면 된다.(내용은 몰라도 된다.)

### 9) 디폴트 메서드와 static메서드 (JDK 1.8)

> 실무에서는 JDK 1.5 ~ 1.6을 많이 사용해서 당분간은 사용할 일이 별로 없음

* 디폴트 메서드
    - 추상 메서드의 기본적인 구현을 제공하는 메서드
* static 메서드
    - Collections클래스에 존재 (11장)

## 8. 내부 클래스

### 1) 내부 클래스란?

* 클래스 내에 선언된 클래스
* 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근
* 코드의 복잡성 줄인다(캡슐화)

### 참고자료

* 자바의 정석 7장
